<!DOCTYPE html><html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>ÙØ§Ø­Øµ Ø¹Ø¨Ø§Ø±Ø§Øª Mnemonic Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª</title>
  <!-- Ù…ÙƒØªØ¨Ø§Øª BIP39 ÙˆHDKey ÙˆEthereumJS ÙˆBitcoinJS -->
  <script src="https://cdn.jsdelivr.net/npm/bip39@3.0.4/browser/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hdkey@1.1.1/dist/hdkey.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethereumjs-util@7.1.3/dist/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bitcoinjs-lib@6.1.0/dist/bitcoinjs.min.js"></script>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    input, button { margin: .5rem 0; width: 100%; box-sizing: border-box; }
    #results { white-space: pre-wrap; background: #f9f9f9; padding: .5rem; border: 1px solid #ddd; max-height: 300px; overflow: auto; }
    .count { font-weight: bold; }
    .good { color: green; }
    .bad { color: red; }
  </style>
</head>
<body>
  <h2>ÙØ§Ø­Øµ Ø¹Ø¨Ø§Ø±Ø§Øª Mnemonic Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Øª</h2>
  <p>Ø§Ø±ÙØ¹ Ù…Ù„Ù TXT ÙŠØ­ØªÙˆÙŠ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø§Øª (12 ÙƒÙ„Ù…Ø©) Ø³Ø·Ø±Ù‹Ø§ Ø¨Ø³Ø·Ø±:</p>
  <input type="file" id="fileInput" accept=".txt">
  <p>Ù…ÙØ§ØªÙŠØ­ API (Ø§ØªØ±ÙƒÙ‡Ø§ ÙØ§Ø±ØºØ© Ø¥Ù† Ù„Ù… ØªØ³ØªØ®Ø¯Ù… Ø§Ù„Ø¹Ù…Ù„Ø©):</p>
  <input type="text" id="etherscanKey" placeholder="Etherscan API Key">
  <input type="text" id="bscscanKey" placeholder="BscScan API Key">
  <input type="text" id="polygonKey" placeholder="Polygonscan API Key">
  <input type="text" id="snowtraceKey" placeholder="Snowtrace API Key">
  <button onclick="scanFile()">ÙØ­Øµ Ø§Ù„Ø¹Ø¨Ø§Ø±Ø§Øª</button>
  <h3>Ø§Ù„Ù†ØªØ§Ø¦Ø¬:</h3>
  <div id="summary">Ù„Ù… ÙŠØªÙ… Ø§Ù„ÙØ­Øµ Ø¨Ø¹Ø¯.</div>
  <div id="results"></div> <script>
    // Ø§Ø´ØªÙ‚Ø§Ù‚ Ø¹Ù†Ø§ÙˆÙŠÙ†
    function deriveBtc(seed) {
      const root = hdkey.fromMasterSeed(seed);
      const child = root.derive("m/44'/0'/0'/0/0");
      return bitcoin.payments.p2pkh({ pubkey: child.publicKey }).address;
    }
    function deriveEvm(seed) {
      const root = hdkey.fromMasterSeed(seed);
      const child = root.derive("m/44'/60'/0'/0/0");
      return '0x' + ethereumjs.Util.pubToAddress(child.publicKey, true).toString('hex');
    }
    // ÙØ­Øµ Ø§Ù„Ø±ØµÙŠØ¯
    async function checkBtc(addr) {
      const res = await fetch(`https://blockstream.info/api/address/${addr}`);
      const data = await res.json();
      return (data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum) > 0;
    }
    async function checkEvm(addr, apiKey, apiUrl) {
      if (!apiKey) return false;
      const res = await fetch(`${apiUrl}?module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`);
      const json = await res.json();
      return parseFloat(json.result) > 0;
    }

    async function scanPhrase(phrase) {
      if (!bip39.validateMnemonic(phrase)) return false;
      const seed = await bip39.mnemonicToSeed(phrase);
      // BTC
      if (await checkBtc(deriveBtc(seed))) return true;
      // ETH
      const ethKey = document.getElementById('etherscanKey').value.trim();
      if (ethKey && await checkEvm(deriveEvm(seed), ethKey, 'https://api.etherscan.io/api')) return true;
      // BSC
      const bscKey = document.getElementById('bscscanKey').value.trim();
      if (bscKey && await checkEvm(deriveEvm(seed), bscKey, 'https://api.bscscan.com/api')) return true;
      // Polygon
      const polyKey = document.getElementById('polygonKey').value.trim();
      if (polyKey && await checkEvm(deriveEvm(seed), polyKey, 'https://api.polygonscan.com/api')) return true;
      // Avalanche
      const avalKey = document.getElementById('snowtraceKey').value.trim();
      if (avalKey && await checkEvm(deriveEvm(seed), avalKey, 'https://api.snowtrace.io/api')) return true;
      return false;
    }

    function scanFile() {
      const file = document.getElementById('fileInput').files[0];
      if (!file) return alert('ÙŠØ±Ø¬Ù‰ Ø±ÙØ¹ Ù…Ù„Ù Ø§Ù„Ø¹Ø¨Ø§Ø±Ø§Øª Ø£ÙˆÙ„Ø§Ù‹');
      const reader = new FileReader();
      reader.onload = async e => {
        const lines = e.target.result.trim().split(/\r?\n/).map(l => l.trim()).filter(l => l);
        const total = lines.length; let good=0, bad=0;
        document.getElementById('summary').innerHTML = `ğŸš€ ØªÙ… ÙØ­Øµ <span class="count">0/${total}</span> Ø¹Ø¨Ø§Ø±Ø©`;
        const resultsDiv = document.getElementById('results'); resultsDiv.textContent = '';
        for (let i=0; i<lines.length; i++) {
          const phrase = lines[i];
          const ok = await scanPhrase(phrase);
          if (ok) { good++; resultsDiv.innerHTML += `<div class="good">âœ… ${phrase}</div>`; }
          else { bad++; resultsDiv.innerHTML += `<div class="bad">âŒ ${phrase}</div>`; }
          document.getElementById('summary').innerHTML = `ğŸš€ ØªÙ… ÙØ­Øµ <span class="count">${i+1}/${total}</span> Ø¹Ø¨Ø§Ø±Ø©`;
        }
        document.getElementById('summary').innerHTML += `<br>`+
          `<span class="good">Ø¹Ø¨Ø§Ø±Ø§Øª ØµØ§Ù„Ø­Ø©: ${good}</span> | `+
          `<span class="bad">Ø¹Ø¨Ø§Ø±Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©: ${bad}</span>`;
      };
      reader.readAsText(file, 'UTF-8');
    }
  </script></body>
</html>
